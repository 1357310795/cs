---
layout:     post
title:      我看过的前端面试题（部分带答案）
subtitle:   记录一些我换工作的时候搜集的以及被问到过的一些面试题
date:       2019-11-18
author:     阿望
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 面试
    - 前端
---

2019年初我准备换工作，便在网上看了一堆现在的前端趋势，多数面试集中在前端基础和vue方面，可能是我现在成长了，也或许是前端本身入门要求就不高，这会儿来整理我之前的面试题，发现面试官们真的，可以说是相当温柔了，一点也不犀利。

本文整理得杂乱无章，不分类别，遇到什么是什么，记录什么写什么。或许这些杂乱无章的总结更能激发你的思考呢。

> vue数据驱动视图变化的原理

vue2.+ ：vuejs在实例化的过程中，会对遍历传给实例化对象选项中的data选项，遍历其所有属性并使用Object.defineProperty把这些属性全部转为getter/setter。同时每一个实例对象都有一个watcher实例对象，他会在模板编译的过程中,用getter去访问data的属性，watcher此时就会把用到的data属性记为依赖，这样就建立了视图与数据之间的联系。当之后我们渲染视图的数据依赖发生改变（即数据的setter被调用的时候，watcher会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。这样就实现了所谓的数据对于视图的驱动。

补充：9102年了，getter/setter已经不能满足面试官了，vue3.0也面世了，记得带一下proxy代理。

> vue-router懒加载的方式：

    当构建的项目比较大的时候，懒加载可以分割代码块，提高页面的初始加载效率。
    1. 异步resolve

    ```
        const routers = [
            {
                path: '/',
                name: 'index',
                component: (resolve) => require(['./views/index.vue'], resolve)
            }
        ]
    ```

    2. import + webpackChunkName（可以使相同webpackChunkName的模块打包在同一个trunk内）

    ```
        const Index = () => import(/* webpackChunkName: "group-home" */  '@/views/index')
        const routers = [
            {
                path: '/',
                name: 'index',
                component: Index
            }
        ]
    ```

    3. require.ensure

    ```
        const Index = r => require.ensure([], () => r(require('./views/index')), 'group-home');
        const routers = [
            {
                path: '/',
                name: 'index',
                component: Index
            }
        ]
    ```

> 移动端响应式实现方式

    1. 固定一个某些宽度，使用一个模式，加上少许的媒体查询方案
    2. 使用flexbox解决方案
    3. 使用百分比加媒体查询